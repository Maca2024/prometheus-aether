import { create } from 'zustand'

// ============================================================
// Types
// ============================================================

export type AtomField = 'role' | 'context' | 'goal' | 'process' | 'format'

export interface PromptAtoms {
  role: string
  context: string
  goal: string
  process: string
  format: string
}

export interface ChatMessage {
  id: string
  role: 'user' | 'assistant' | 'system'
  content: string
  timestamp: number
}

export type ActiveTab = 'pentagon' | 'spectrum' | 'builder' | 'validator' | 'chat'

export interface ValidationResult {
  role: boolean
  context: boolean
  goal: boolean
  process: boolean
  format: boolean
  score: number
  tips: string[]
}

// ============================================================
// UI Store
// ============================================================

interface UIState {
  activeTab: ActiveTab
  activeAtom: AtomField | null
  activeSpectrumLevel: number
  isMobileMenuOpen: boolean
  setActiveTab: (tab: ActiveTab) => void
  setActiveAtom: (atom: AtomField | null) => void
  setActiveSpectrumLevel: (level: number) => void
  setMobileMenuOpen: (open: boolean) => void
}

export const useUIStore = create<UIState>((set) => ({
  activeTab: 'pentagon',
  activeAtom: null,
  activeSpectrumLevel: 1,
  isMobileMenuOpen: false,
  setActiveTab: (tab) => set({ activeTab: tab }),
  setActiveAtom: (atom) => set({ activeAtom: atom }),
  setActiveSpectrumLevel: (level) => set({ activeSpectrumLevel: level }),
  setMobileMenuOpen: (open) => set({ isMobileMenuOpen: open }),
}))

// ============================================================
// Prompt Builder Store
// ============================================================

interface PromptState {
  atoms: PromptAtoms
  generatedPrompt: string
  validationInput: string
  validationResult: ValidationResult | null
  setAtom: (field: AtomField, value: string) => void
  generatePrompt: () => void
  clearAtoms: () => void
  setValidationInput: (input: string) => void
  validatePrompt: () => void
}

const VALIDATION_KEYWORDS: Record<AtomField, string[]> = {
  role: ['role', 'als een', 'jij bent', 'you are', 'act as', 'speel de rol', 'expert', 'specialist'],
  context: ['context', 'situatie', 'achtergrond', 'we zijn', 'we are', 'project', 'scenario', 'background'],
  goal: ['goal', 'doel', 'taak', 'task', 'missie', 'objective', 'wat we willen', 'create', 'build', 'make'],
  process: ['process', 'stap', 'step', 'hoe', 'aanpak', 'procedure', 'workflow', 'first', 'then', 'finally'],
  format: ['format', 'output', 'vorm', 'structuur', 'json', 'xml', 'markdown', 'table', 'list'],
}

export const usePromptStore = create<PromptState>((set, get) => ({
  atoms: { role: '', context: '', goal: '', process: '', format: '' },
  generatedPrompt: '',
  validationInput: '',
  validationResult: null,

  setAtom: (field, value) =>
    set((state) => ({ atoms: { ...state.atoms, [field]: value } })),

  generatePrompt: () => {
    const { atoms } = get()
    if (!atoms.context.trim() || !atoms.goal.trim()) return

    const parts: string[] = []
    if (atoms.role.trim()) parts.push(`ROLE:\n${atoms.role.trim()}\n`)
    parts.push(`CONTEXT:\n${atoms.context.trim()}\n`)
    parts.push(`GOAL:\n${atoms.goal.trim()}\n`)
    if (atoms.process.trim()) parts.push(`PROCESS:\n${atoms.process.trim()}\n`)
    if (atoms.format.trim()) parts.push(`FORMAT:\n${atoms.format.trim()}\n`)
    parts.push('---\nGenerated by PROMETHEUS AETHER')

    set({ generatedPrompt: parts.join('\n') })
  },

  clearAtoms: () =>
    set({
      atoms: { role: '', context: '', goal: '', process: '', format: '' },
      generatedPrompt: '',
    }),

  setValidationInput: (input) => set({ validationInput: input }),

  validatePrompt: () => {
    const { validationInput } = get()
    const lower = validationInput.toLowerCase()
    const results: Record<AtomField, boolean> = {
      role: false,
      context: false,
      goal: false,
      process: false,
      format: false,
    }

    for (const [field, keywords] of Object.entries(VALIDATION_KEYWORDS)) {
      results[field as AtomField] = keywords.some((kw) => lower.includes(kw))
    }

    const tips: string[] = []
    if (!results.context) tips.push('Add CONTEXT with background information about the situation.')
    if (!results.goal) tips.push('Make GOAL explicit â€” what exactly must happen?')
    if (!results.role) tips.push('Consider adding a ROLE to define expertise.')
    if (results.role && results.context && results.goal && !results.process)
      tips.push('Consider adding PROCESS for complex tasks with multiple steps.')
    if (!results.format) tips.push('Specify FORMAT for consistent, structured output.')

    const essentials = [results.context, results.goal].filter(Boolean).length
    const optionals = [results.role, results.process, results.format].filter(Boolean).length
    const score = Math.round(((essentials * 2 + optionals) / 7) * 100)

    set({ validationResult: { ...results, score, tips } })
  },
}))

// ============================================================
// Chat Store
// ============================================================

interface ChatState {
  messages: ChatMessage[]
  isStreaming: boolean
  sessionId: string | null
  addMessage: (msg: Omit<ChatMessage, 'id' | 'timestamp'>) => void
  setStreaming: (streaming: boolean) => void
  setSessionId: (id: string | null) => void
  clearMessages: () => void
}

export const useChatStore = create<ChatState>((set) => ({
  messages: [],
  isStreaming: false,
  sessionId: null,

  addMessage: (msg) =>
    set((state) => ({
      messages: [
        ...state.messages,
        { ...msg, id: crypto.randomUUID(), timestamp: Date.now() },
      ],
    })),

  setStreaming: (streaming) => set({ isStreaming: streaming }),
  setSessionId: (id) => set({ sessionId: id }),
  clearMessages: () => set({ messages: [] }),
}))

// ============================================================
// Auth Store
// ============================================================

interface AuthState {
  user: { id: string; email: string; name: string; avatar: string; role: string } | null
  isLoading: boolean
  setUser: (user: AuthState['user']) => void
  setLoading: (loading: boolean) => void
  logout: () => void
}

export const useAuthStore = create<AuthState>((set) => ({
  user: null,
  isLoading: true,
  setUser: (user) => set({ user, isLoading: false }),
  setLoading: (loading) => set({ isLoading: loading }),
  logout: () => set({ user: null }),
}))
